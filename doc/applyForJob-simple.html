<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<link rel="stylesheet" href="//normalize-css.googlecode.com/svn/trunk/normalize.css" />


<!-- always required -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>

<!-- needed for sequence diagrams -->
<script type="text/javascript" src='http://talentappstore.github.io/tas-des-static/js/raphael-min.js'></script>
<script type="text/javascript" src='http://talentappstore.github.io/tas-des-static/js/underscore-min.js'></script>
<script type="text/javascript" src='http://talentappstore.github.io/tas-des-static/js/sequence-diagram-min.js'></script>
<script type="text/javascript" src='http://talentappstore.github.io/tas-des-static/js/sequence-diagram-wrapper.js'></script>

<!-- needed for includes -->
<script type="text/javascript" src='http://talentappstore.github.io/tas-des-static/js/clientInclude.js'></script>

<!-- needed for table of contents -->
<script type="text/javascript" src='http://talentappstore.github.io/tas-des-static/js/tocify.js'></script>

<!-- always required -->
<link rel='stylesheet' href='http://talentappstore.github.io/tas-des-static/css/des.css' type='text/css' media='all' />


<title>Apply for opening - simple</title>
</head>
<body>

<div id="toc"></div>


<h1>Discuss</h1>

<ul>
<li>keying of drafts (candidate /E/N ?)
<li>use of the email IdP. When candidates apply using email, instead of social login, do we want to be able to leverage
their email field without forcing them back to the email IdP for link verification?
</ul>

<h1>Scenario</h1>

<p>This scenario involves these apps:
<ol>
<li>jobly, a simple ATS that renders the opening details page with an "apply now" button embedded in it
<li>simpleapply, an app that provides the "apply now" user interface, and pushes the job application into the ATS
<li>tracker, an app that provides the TAS tracker functionality
</ol>
</p>

<p>In this scenario, a candidate:
<ol>
<li>visits the tenant's corporate careers site hosted by jobly to look at a specific opening
<li>clicks apply now
<li>is sent to the simpleapply app
<li>logs in using Google
<li>completes a job application   
</ol>
</p>

<p>Other scenarios that are also handled by simpleapply, but not covered in this doc:
<ol>
<li>Candidate "registers" interest (does not apply for any specific job), possibly for a given category (e.g. Marketing)
<li>Candidate views their "existing data" (e.g. their resume, profile) using simpleapply, but within some larger container that lets also navigate to:
<ul>
<li>their in progress job applications
<li>their draft job applications (held by simpleapply)
</ul>
<li>Candidate applies for a shopping cart of jobs in one operation
<li>candidate clicks on a job they have already have a draft for
<li>candidate clicks to apply for a job that has a gating job 
</ol>
</p> 


<h1>Jobly (ATS) renders the job details page</h1>

<h2>Create a tracker</h2>

<p>In this scenario, jobly, the ATS, has its own particular system for
candidate source tracking which involves passing a candidateSource parameter.</p>

<p>In this example, the candidate has reached the job by clicking on this link (within a Facebook post):</p>

<div class='codeBlock'>
https://acme.jobboard.com/openings/7622?candidateSource=facebook
</div>

<p>The TAS tenant APIs use a different convention for source tracking, called tracker.

<p>If jobly was tracker-aware, the URL would have looked more like this (and jobly would not have needed to
create the campaign tracker:</p>

<div class='codeBlock'>
https://acme.jobboard.com/openings/7622?tracker=73947484
</div>

<p>Before it can render the simpleapply button, jobly needs to encapsulate
the candidateSource data inside a tracker, that can be passed through the chain as follows:</p>

<div class='codeBlock'>
(entry URL) -> job details page (jobly)  -> apply pages (simpleapply) -> REST API call for new job application -> (jobly)
</div>

<p>Jobly checks whether it is already holding a tracker for the candidate's session (see detailed notes on tracker for more). In this
example we assume that jobly finds that the candidate's http session already holds a tracker:

<div class='codeBlock'>
HttpSession session = ... 
Integer existingTracker = session.getAttribute("tracker"); // tracker 603343 is found
</div>
</p>

<p>Jobly now creates a new tracker to embed the new information (candidateSource). Since this is not
a session creation event, jobly uses a campaign tracker. The new tracker is linked to the existing tracker.
</p>

<p>In this example, jobly parses the candidate source out and adds it as a custom field inside the userArea section.
<div class='codeBlock'>
POST /trackers/603343/trackers/acme/supersoft/jobly
<div class='clientInclude' data-href='../examples/tracker-createLegacySourceTracker.json'></div>

Response: 201
Location: 763019932
</div>


<h2>Embed the apply now button</h2>

<p>With the tracker set up, the ATS/job board (jobly) can now ask
all interested apps whether they have a candidate-facing widget
(e.g. an apply button, social sharing tool, view counter, etc.)
that they would like to inject into the job details page.</p>

<p>Since the candidate is not logged in jobly uses an anonymous OAuth token.</p>

<div class='codeBlock'>
(jobly)
GET /jobs/7622/widgetHtml/candidates/me?tracker=763019932

...
</div>

<p>In order to render its button, simpleapply looks at the <b>sub</b> field within the OAuth token. In this case
the field is not present, so simpleapply knows the OAuth token is anonymous. This means that simpleapply can't, for example,
see if the candidate has applied previously and if so add a message "You've already applied".</p>

<p>Instead, simpleapply displays whatever is appropriate for a completely unknown candidate.</p>

<p>Note: even without a logged in candidate, these widget rendering apps could adapt their behaviour based on the data
in the tracker, e.g. for candidates on a mobile device:
<ul>
<li>One apply mechanism (the desktop experience) stops rendering its button
<li>Another (the mobile experience) starts rendering its button
</ul>  
</p>

<div class='codeBlock'>
(jobly)
GET /jobs/7622/widgetHtml/candidates/me?tracker=763019932

Response (from simpleapply):
&lt;button onClick="https://acme.simpleapply.com/openings/7622?tracker=763019932&relayPage=acme.jobly.com/openings/7622"&gt;Apply now&lt;/button&gt;
</div>

<h1>Candidate clicks apply</h1>

<p>The entire job details page, and the apply button within it, are now rendered, so the candidate sees the "apply now" button at
the bottom of the job description, and by clicking on it, is sent to simpleapply at this URL:</p>

<div class='codeBlock'>
https://acme.simpleapply.com/jobs/7622?tracker=763019932&relayPage=acme.jobly.com/jobs/7622
</div>

<p>If the candidate was logged in at jobly (e.g. to save some jobs to a cart), then jobly will pass a hint to
simpleapply that the candidate is already logged in:
</p>

<div class='codeBlock'>
https://acme.simpleapply.com/jobs/7622?tracker=763019932&relayPage=acme.jobly.com/jobs/7622?loggedIn=true
</div>
 
<h1>Simpleapply renders its page (candidate not logged in)</h1>

<p>simpleapply now renders its page.</p>

<h2>Check for logged in candidate</h2>

<p>simpleapply is able to render its "apply form" to either a logged in candidate, or to an anonymous web visitor
(though the anonymous visitor can't complete the form but can only view it).</p>

<p>However due to the nature of SSO, simpleapply is unable to detect whether
the visitor is logged into the SSO system or not. Therefore it looks to the loggedIn
URL parameter for a hint. By convention, TAS apps that hyperlink to other TAS apps
always attach the loggedIn URL parameter as a hint when the principal (i.e. the
candidate) is already logged in.</p>

<div class='codeBlock'>
https://acme.simpleapply.com/jobs/7622?tracker=763019932&relayPage=acme.jobly.com/jobs/7622
</div>

<p>In this example, the URL does not have the loggedIn parameter, <b>and</b> the target page is one
that can render itself whether or not there is a logged in candidate, so simpleapply begins to render
the page for a non-logged in candidate.

<h2>Render for non-logged in candidate</h2>

<p>simpleapply's goal is to show as much as possible of the apply "form" to the
candidate, so that they can assess how much work it will be, and hopefully be
enticed by simpleapply's support for cloud storage (dropbox etc.) for resumes,
mobile-friendly UI, etc.
</p>

<p>In this example the candidate is not yet logged in, simpleapply can't check for role==internal
on the TAS session - instead it can only show those questions that an external candidate would need to answer.
If the job is internal only, simpleapply would show no details at all, and would only offer the candidate a way
to log in (so they could prove they were internal).
</p>

<p>Deciding what to display to the candidate may involve complex logic, which
does not belong inside simpleapply, but is more likely in the ATS.</p>

<h2>simpleapply fetches edit spec for non-logged in candidate</h2>

<p>simpleapply asks for an <b>edit spec</b>, a document that describes what data
is required of the candidate to apply for the job. Since there is no candidate logged in,
simpleapply uses an anonymous OAuth token (i.e. one not associated with a principal), which
jobly (the ATS) interprets as a request for a "safe" edit spec that anyone is allowed to see.  


<div class='codeBlock'>
POST /editSpecs/fetches

Request:
<div class='clientInclude' data-href='../examples/intent-apply.json'></div>

</div> 
</p>

<p>The response includes all the information needed to render the apply form to an
anonymous candidate (we look in more detail later).</p>

<p>We want them to see how easy the process was, but so that no-one can actually apply until they are logged in,
simpleapply renders the form with all fields disabled.  
</p>

<h1>Candidate logs in to simpleapply</h1>

<p>The candidate sees the apply form, and decides that they are prepared to invest
their time in applying, so logs in using Facebook and returns to the simpleapply page.</p>


<h2>The session gets decorated</h2>

<p>Once the candidate has logged in, their TAS session contains their roles (e.g. role == internal).</p> 

<p>This section describes how this happens.</p>

<p>When the candidate logs in, their TAS session gets decorated (e.g. has roles injected) by the
originating idp and by all of the apps that are acting as login listeners.</p>

<p>So role == internal could have come:

<ul>
<li>directly from the idp, e.g.:
<ul>
<li>because everyone in the corporate idp gets the role
<li>because people matching the corporate email pattern get the role
</ul>
<li>from the ATS - e.g. because jobly's login listener detected the login, looked up the name ID (typically email) in its own
candidates table, found a row, saw it was marked as internal, and therefore injected role==internal.
</ul>
<li>from a more exotic login listener, e.g. some special login listener did it that that provides a
brute force "I am an internal" link on the intranet that employees click through from
</ul>
</p>

<h1>Simpleapply renders its page (candidate logged in)</h1>

<h2>Re-fetch the edit spec</h2>

<h3>Absorb the candidate's existing information into the intent</h3>

<p>Now that the candidate has logged in, simpleapply is ready to re-fetch the application form,
this time for real (e.g. maybe now jobly knows who the candidate is, it can detect they've been black-listed and prevent the apply altogether).</p>

<h3>Design decision - replace vs. merge of the candidate's categories</h3>

<p>The <b>POST /candidates</b> API, which simpleapply will
eventually use to push the edit into the jobly ATS, supports two modes for setting the candidate's categories.

<dl>

<dt>merge</dt><dd>The category values in the request are merged with any existing values on the
candidate. Suitable for one-click or offline scenarios, e.g. "enter your email here to hear about new finance jobs", where the
UI never had a chance to query the candidate's existing data, and does not want to overwrite it.</dd>

<dt>replace</dt><dd>The category values in the request completely replace any existing values on the candidate. Suitable for
online scenarios, like a conventional apply form, where the candidate logs in and the UI has a chance to present all of their
new and existing categories to them for tailoring.</dd>
</dl>

<p>Simpleapply uses <b>replace</b> semantics. Read the rest of this section for more details or skip on.</p> 

<p>TODO: make clearer.</p>

<p>At the moment, the intent contains no categories, just the job that the candidate wants
to apply to. When we get the edit spec back from jobly
we might find some categories in there that were implied by the job for example the
job "Co-pilot long-haul, Pacific" might imply expertise == pilot, which might in turn unlock some
data entry fields to do with being a pilot.</p>

<p>However simpleapply now wants to merge in any existing category values that <b>the candidate already
has</b> (assuming they have a row in the ATS).</p>

<p>For example the candidate might have previously profiled themselves as expertise == CEO.</p>

<p>Simpleapply's philosophy is to encourage candidates to keep their profiles accurate, so in this
case it wants to add CEO to the intent.</p>

<p>This may result in the apply form containing information relevant
to CEO, possibly confusing the candidate who thought they were applying to be a pilot,
and has forgot that they had partially profiled themselves as CEO. On the other hand, it may encourage them
to unprofile themselves as CEO, keeping the database cleaner.
</p>

<p>In summary, simpleapply uses the philosophy of presenting to the candidate their entire category selections,
allowing them to make changes, and then completely overwriting (with semantics == replace) the categories
on their candidate record.<p>

<p>Another philosophy would be for simpleapply to only present the categories related
to the job the candidate was applying to, ignoring any other stuff lurking on their
candidate record, and then use semantics == merge when applying the changes to the
candidate record (via POST /candidates). The advantage to this is that the candidate only has to
provide valid data for the job they are applying to, and does not have to clean up their record as a whole.</p>

<h3>Fetching the candidate's existing information into the intent</h3>
 
<p>Since simpleapply is going to use replace semantics for the candidate's categories, it now needs to
fetch any existing categories from the candidate's record.</p>

<p>First, see if there even is a candidate record. A candidate may be logged in (maybe via their facebook account)
but not have any row in the ATS.</p>

<div class='codeBlock'>
GET /candidates/{N}

Response:
3022432
</div> 

<p>Looks like there is a candidate record already. Grab the candidate's existing categories.</p>

<div class='codeBlock'>
GET /candidates/3022432/categories

Response:
[
    {
        "id": 10032,
        "values": [
            3344
        ]
    },
    {
        "id": 10034,
        "values": [
            1001
        ]
    }
]
</div> 

<p>Now merge them into the intent. The intent now looks like this:</p>

<div class='codeBlock'>
<div class='clientInclude' data-href='../examples/intent-applyPlusExistingCats.json'></div>
</div>

<p>In this case it was easy to merge the existing categories into the intent, since the intent had no categories.
If there had been some category values already in the intent (e.g. the candidate
is applying for a job and at the same time registering interest in the Finance area), then a simple overwrite like
this would not work - instead simpleapply would use the merge helper to merge the two sets of categories into one like this:</p>

<p>TODO: Insert example of merging two sets of categories using POST /categoryMerges</p>


<h3>Fetch the edit spec again</h3>

<p>Now:

<ol>
<li>The candidate has logged in
<li>We've created an intent which indicates
<ul>
<li>what categories they want to end up
with, i.e. the sum of what they already had and any new ones (in this case none)
<li>what jobs they want to apply for
</li>
</ol>

<p>Simpleapply again fetches the edit spec, this time using the new intent.</p>

<p>To build the edit spec, the ATS (jobly) will use data from:
<ul>
<li>the TAS session - e.g. details of the candidate's role(s) from the TAS session (e.g. whether they are internal)
<li>the ATS database - e.g. whether the candidate has been made
redundant within the last 2 years, or failed a drug test during a previous recruitment process,
and hence cannot apply at all
</ul>

<p>Note that the amended intent may indicate that, even though the candidate wishes to apply for some given job, the ATS
may have other plans for them and may have amended their intent(in this case
the message should explain to the candidate what and why). For example:</p>

<ul>
<li>candidate applying for pilot jobs must also select a category value for pilot
<li>candidates applying to some specific customer service job must first apply to a customer service talent pool role
</ul>

<p>Simpleapply fetches the edit spec.</p>

<div class='codeBlock'>
POST /editSpecs/fetches

Request:
<div class='clientInclude' data-href='../examples/intent-applyPlusExistingCats.json'></div>

Response:
<div class='clientInclude' data-href='../examples/candidateEditSpec-apply.json'></div>

</div> 
</p>

<p>Great! Now simpleapply has the details it needs to begin building its UI.</p>
 
<h2>Set up UI</h2>

<p>Simpleapply creates the UI that it will display to the candidate.</p>

<h3>Display the message</h3>

<p>At the top of the page, simpleapply displays the message (if any) in the style suggested. In a situation where the job is internal only,
and the candidate is not internal, there might be nothing displayed but the message. In other situations there might be no message at all.</p> 

<h3>Set up input fields and controls</h3>

<p>simpleapply now uses the information from the <b>inputModel</b> section to set up the UI - i.e. when
applying for a job, the inputModel is more or less the application form.</p>

<p>For example, the resumeRule section tells simpleapply it should provide a way to upload a resume, but it is not mandatory.</p>

<p>Most of the information from the inputModel relates to
the candidate as a whole, but some is specific to individual
job application(s) (under the <b>openingRules</b> section). Simpleapply
arranges the opening-specific sections under appropriate headers ()with job title).

<h3>Populate default values</h3>

<p>The inputModel also includes some default values, e.g. for individual fields in the items
section(s). These should be loaded into the input controls.</p> 

<p>Default values are not the same as previously entered values.</p>



<h3>Setup voice message capture</h3>

<p>If the inputModel indicates a voice message is required or mandatory, then jobly first requests an id that the
recording will be held against:
<div class='codeBlock'>
POST /voiceMessageUploads

Response:
170033
</div>
</p>

<p>jobly next asks the voice recording app for the recording UI, further passing in the tracker.
<div class='codeBlock'>
GET /voiceMessageUploads/{id}/recordingUI&tracker=763019932

Response:
https://acme.voicely.com/170033/recordingUI.html?tracker=763019932
</div>

<p>And finally jobly also displays any existing voice message so the candidate can decide whether to
record a new one or stick with the one they already have.
</p>

<p>First get the lock id for the existing voice message:
<div class='codeBlock'>
GET /candidates/{}/voiceMessage

Response: 2044
</div>

<p>Now get the playback UI for the message:
<div class='codeBlock'>
GET /voiceMessageUploads/locked/2044/playbackUI

Response:
https://acme.voicely.com/170033/playbackUI.html?tracker=763019932
</div>

<p>Now we have a UI to capture a voice message.
</p>

<h3>Populate category controls</h3>

<p>Since categories may be large (e.g. a definitive list of every county in the US) it's up to simpleapply to decide
how to fetch all possible values so the user can select. For small categories, simpleapply might fetch the entire
category. For larger ones, it might use ajax calls to only fetch values as, say, the user clicks to expand a node in the hierarchy.
</p>


<div class='codeBlock'>
Get list of all categories ..
GET /categories

.. and its tree of nodes
GET /categories/10033/values
</div>


<h2>Fetch previously entered data</h2>

<p>Once the UI has been laid out, simpleapply next needs to load the fields with any existing data (this only
applies when there is an existing candidate record). Specifically:

<ul>
<li>the amended intent provides the full set of category values
<li>in the case of existing candidates, the fine-grained candidate APIs (e.g. GET /candidates/{}/resume) provide access to the
data already held in the ATS
<li>Some data is also available on the TAS session from the idp and/or login listeners. For example if the candidate has
logged in using Facebook, then their name and image may be available on the TAS session.
</li>
</ul>

<h3>Loading existing category values</h3>
<h3>Using fine-grained candidate APIs</h3>

<h4>Load existing resume</h4>

<p>Simpleapply fetches details of the candidate's existing resume (not the stream itself which might be enormous)

<div class='codeBlock'>
GET /candidates/3022432/resume/meta

Response:
<div class='clientInclude' data-href='../examples/fileDownload-simple.json'></div>
</div> 

<p>Simpleapply also displays a link which the candidate can click through on to open their existing resume document. 

<div class='codeBlock'>
GET /candidates/3022432/resume/asStream
</div> 

<h4>Load details of existing applications</h4>

<p>If the candidate already has a record in the database, Simpleapply now loads up any
previously entered candidate data for the job application(s).</p>    

<p>Normally candidates are applying from scratch, so there is no previous data, and then once
they have applied, they cannot go back and change any application data.</p>

<p>But its possible that the candidate has previously submitted this application. This could happen if:
<ul>
<li>they submitted it through some thin, offline client, and now we are
asking them to go back and re-submit with more information
<li>the application is to some kind of talent pool/continuous opening,
and they have sat out some stand-down period and are now able to re-apply.
</ul>
</p>

<div class='codeBlock'>
GET /applications/byCandidate/{candidateID}/byOpening/{openingID}

Response:
902533

GET /applications/902533/items
</div>


<h3>Using data from the TAS session</h3>
TODO: clarify storage of the image - TAS core API??



<h1>Candidate fills out apply form</h1>

<p>simpleapply now renders the page to the candidate, who can start editing, selecting and generally completing the form.</p> 

<h2>Candidate uploads a new resume</h2>

<p>The candidate wants to replace their existing resume, so uploads a new document which simpleapply stores somewhere, perhaps
in a temporary file.</p>   

<h2>Save draft</h2>

<p>simpleapply includes draft functionality. The user can save their work in some database (perhaps nosql) and return later.</p>

<p>Those drafts are keyed by candidate name ID alone (there may be no id yet if the candidate is new), and each draft may
hold details for several jobs (even if UberApply only submits them one at a time).
</p>

<p>The ATS (jobly) is unaware of any draft functionality, simpleapply only pushes completed edits to it.</p> 


<h2>Candidate edits categories</h2>

<p>While the candidate is using simpleapply, they may change their categories.</p>

<p>If they do, then simpleapply must re-fetch the edit spec, since a change in categories may
result in knock on changes in the amended intent, and in the input model (e.g. a candidate who
adds expertise == pilot must now answer additional questions).</p>

<p>This may be quite involved for simpleapply, as it needs to temporarily
preserve any data from the fields (perhaps using its own draft functionality), rebuild the UI
using the new edit spec, then reapply that data.</p> 

<h2>More candidate interactions with the apply form</h2>

<pre>
 
candidate clicks to view an existing (exists back on their candidate record) document attachment/CV 

candidate clicks to view a newly added (only present in draft) document attachment/CV
 
candidate deletes an existing answer (a no longer required one? any one?)

candidate deletes an existing document attachment/CV

candidate deletes a newly added document attachment/CV

candidate completes their application (draft gets deleted)

candidate deletes a draft application

candidate deletes their entire profile (maybe another app?)
</pre>


<h1>Candidate submits application</h1>

<p>If simpleapply allowed the candidate to record a new voice message, it must now check (by trying to lock) if they did so using
the previously generated id.

<div class='codeBlock'>
POST /voiceMessageUploads/170033/lock

Response:
201
</div>
</p>

<p>Looks like they did record one. simpleapply packs the lock id into the body for the call to POST /candidates.
</p>

<p>If the candidate was to delete this drfat, simpleapply would need to clean up and delete the message (since it had not been handed off to the ATS).
</p>

<p>Once the candidate has finally completed their work and pressed submit, the completed edit (i.e., job application in
this example]) is sent to the ATS (jobly).
</p>

<div class='codeBlock'>
POST /candidates

Response:
<div class='clientInclude' data-href='../examples/candidateEdit-simple.json'></div>
</div> 

<h2>ATS processes the event</h2>

TODO: clean up any existing messages. 

<p>The ATS processes the event. This may result in creating a new candidate or updating an existing one.
</p>

<h2>Processing the tracker</h2>

<p>The ATS fetches the chain of trackers, starting from the one passed across to POST /candidates.</p>

<div class='codeBlock'>
GET /trackers/763019932/chain

Response:
<div class='clientInclude' data-href='../examples/trackers-legacyATS.json'></div>
</div>

<p>Now the ATS applies its custom logic to cope with its own source conventions.</p>

<p>In the case of jobly, it wants two pieces of metadata about the application:
<ol>
<li>candidateSource
<li>deviceClass
</ol>

<p>The ATS first looks to see if these were passed in, and if not it establishes them from the information in the trackers.</p>

<div class='codeBlock'>
TODO: cleanup

// see if candidateSource was passed in
candidateSource = destinationTracker.meta.candidateSource;
if (candidateSource == null)
   // source was not passed in, so derive it from the visit tracker's fields
   candidateSource = extractCandidateSource(visitTracker.landingURI);
 
// likewise for device class
deviceClass = destinationTracker.meta.deviceClass;
if (deviceClass == null)
   // deviceClass was not passed in, so derive it from the user agent
   // this ATS might use a user agent database to resolve down to mobile == true or false for example
   deviceClass = extractDeviceClass(visitTracker.userAgent)
</div>

 
<h1>Candidate is redirected back to job details page</h1>

<p>Based on the http result from the event post, simpleapply then displays the "Successful" page.</p>

<p>A button on that page links the user back to the relay page (i.e the
original job details page in this example of applying for a job).</p>

<p>User is now back at the job details page.</p>



<script>
$(document).ready(function() {

	renderSequenceDiagrams();
	renderClientIncludes();
	renderTOC();
});
</script>


</body>
</html>