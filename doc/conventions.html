<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<!-- always required -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>

<!-- needed for sequence diagrams -->
<script type="text/javascript" src='http://talentappstore.github.io/tas-des-static/js/raphael-min.js'></script>
<script type="text/javascript" src='http://talentappstore.github.io/tas-des-static/js/underscore-min.js'></script>
<script type="text/javascript" src='http://talentappstore.github.io/tas-des-static/js/sequence-diagram-min.js'></script>
<script type="text/javascript" src='http://talentappstore.github.io/tas-des-static/js/sequence-diagram-wrapper.js'></script>

<!-- needed for includes -->
<script type="text/javascript" src='http://talentappstore.github.io/tas-des-static/js/clientInclude.js'></script>

<!-- needed for table of contents -->
<script type="text/javascript" src='http://talentappstore.github.io/tas-des-static/js/tocify.js'></script>

<!-- always required -->
<link rel='stylesheet' href='http://talentappstore.github.io/tas-des-static/css/des.css' type='text/css' media='all' />


<title>Conventions</title>
</head>
<body>

<div id="toc"></div>


<h1>Conventions</h1>

<p><b>Conventions</b> are patterns or practices that we follow at TAS when defining APIs and developing apps.</p>

<p>The TAS core itself knows nothing about conventions, so when building apps you can follow these conventions or not as suits you.</p>


<h1>Replication convention</h1>

<p>Replication is a convention/pattern that allows one or more <b>replication secondary</b> apps to maintain a real-time copy
of the master data held on a single <b>replication primary</b> app.</p>

<p>For example:
<ul>
<li>the replication primary app might be an ATS that produces an API like <b>GET /jobs</b>
<li>the replication secondary app might be a job board that wants to maintain its own local database of jobs, kept in synch with the jobs held on the ATS  
</ul>

<p>You shouldn't use replication unless you need to. In the example above, the job board might be able to simply call <b>GET /jobs</b> each time a
candidate visited the site. However sometimes replication is required.</p>

<p>The TAS core itself is unaware of the concept of replication. Replication is simply tenant API calls between apps as far as TAS is concerned. Your app can approach
replication in any way it wants - there is no need for it to follow this pattern. However if it does, your app will be more likely to interoperate with other apps.</p>  

<h2>Features</h2>

<p>The replication pattern described here:

<ul>
<li>Is real-time (non-polling)
<li>Supports partial replication - the secondary can choose to maintain a subset of the instances of the master records (e.g., only jobs that are currently open) 
or a subset of the properties on the instances (e.g. only the job's title, and not its description or attached documents).
<li>Relies on a bulk load phase, where immediately after install, the secondary gradually loads up all of the master data that already exists at the primary. The pattern
is best suited to a single-threaded implementation.
</ul> 


<h2>Overview</h2>

<p>Following the standard replication pattern, the ATS and job board apps in the example above would work together as below:

<ul>
<li>A tenant has already installed the ATS app (the primary)
<li>The tenant installs the job board app (the secondary)
<li>The job board app starts its bulk loading phase
<li>The job board repeatedly calls GET /jobs/{} until it has loaded all of the existing jobs from the ATS
<li>Since the bulk load phase might take hours, or days, the job board keeps track of the most recently loaded job in a persistent store (such as the repstate app), so that it can pick up and continue the bulk load phase if the tenant is disrupted, or the app itself is restarted
<li>Eventually the job board's bulk load phase is complete
<li>The job board now listens for incoming alerts about changes to the master set of jobs  
<li>At some point, a new job is created inside the ATS
<li>The ATS sends a "ping" to the job board to alert it of the new data
<li>Unless the ping is for a delete, the job board calls GET /jobs/{} to fetch the new/updated data, and updates its local database
</ul>



<h2>Example API flow</h2>

<p>Below is a detailed message sequence diagram showing the API flows between replication primary and secondary and TAS.</p>

<p>In this example, the replication primary is an ATS holding the master set of candidates, and the replication secondary is a new
candidate search app called "ferret".</p>

<p>This example also shows the use of the repstate app, which acts as a persistent store for the secondary's state during the bulk load phase.</p>

<div class='seqDiag' id="repexample">

participant ats
participant ferret
participant repstate
participant TAS

note left of TAS: tenant acme installs the ferret app
TAS->ferret: POST /tenants/acme
note left of ferret: ferret knows it is a replication\nsecondary for candidates,\ninitializes the replication state store
ferret->repstate: POST /repstates/ferret/tas/%2Fcandidates\n{"loading"":true,lastLoaded:null}
note left of ferret: ferret asks for id of first candidate
ferret->ats: GET /candidates?$orderby=id&$select=id&$top=1
note right of ats: ats says 10234
note left of ferret: ferret calls its own onPing() method\nwhich fetches full details from the primary
ferret->ats: GET /candidates/10234?$select=resume
note right of ats: ats passes back resume
ferret->repstate: POST /repstates/ferret/tas/%2Fcandidates\n{"loading"":true,lastLoaded:10234}

note left of ferret: ferret asks for id of next candidate
ferret->ats: GET /candidates?$orderby=id&$select=id&$top=1&$filter=id gt 10234
note right of ats: ats says 10235
ferret->ats: GET /candidates/10235?$select=resume
note right of ats: ats passes back resume
ferret->repstate: POST /repstates/ferret/tas/%2Fcandidates\n{"loading"":true,lastLoaded:10235}

note right of ats: ..time passes..

note right of ats: a database trigger fires in the ats,\nreflecting that a new candidate has been created
note right of ats: this is the first time that ats\nhas tried to broadcast\nto this API for tenant acme,\nso asks TAS who produces that API
ats->TAS: GET /tenants/acme/routes/ats/tas/%2Fm%2Fcandidates%2F%7BcandidateID%7D%2FdeltaPings
note left of TAS: TAS says:\n"items": [{"producer": "ferret",\n"location": "https://acme.ferret.com/"},..]
note right of ats: ats now sends message to say\nthat a new candidate has been created
ats->ferret: POST /m/candidates/29046/deltaPings\n{"operation": "insert"}
note right of ferret: to decide whether to ignore the ping,\nferret needs to know the current\nstate of the replication secondary.\nIt could have this in memory or it\nit may be easier for the API handler\nto fetch it from the replication\nstatus store.
ferret->repstate: GET /repstates/ferret/tas/%2Fcandidates\n{"loading"":true,lastLoaded:10235}
note left of ferret: ferret onPing()\nif (!loading || id <= lastID) absorbPing();\nignores the ping

note left of ferret: ferret asks for id of next candidate
ferret->ats: GET /candidates?$orderby=id&$select=id&$top=1&$filter=id gt 10235
note right of ats: ats says 404 error
note left of ferret: replication bulk load is complete
ferret->repstate: POST /repstates/ferret/tas/%2Fcandidates\n{"loading"":false,lastLoaded:null}
</div>


<h2>APIs required for replication</h2>

<p>As seen above, for a given types of master data (e.g. jobs), replication requires the following APIs:

<ul>
<li>Produced by the primary and consumed by the secondary
<ul>
<li>Get a master record by its "primary key", e.g. <b>GET /jobs/{jobID}</b><br />
<li>Get the master record with the first/lowest primary key value, e.g. <b>GET /jobs?$orderby=id&$top=1</b><br />
<li>Get the master record with the next primary key value, e.g.: <b>GET /jobs?$filter=id gt 100&$orderby=id&$top=1</b><br />
</ul>
<li>Produced by the secondary and consumed by the primary
<ul>
<li>Alert secondaries of a change to a master record, e.g. <b>POST /jobs/{jobID}/deltaPings</b>.<br />
(The primary must queue pings in the event of any secondary being unavailable, until it becomes available again - it
might use something like a <a href='./broadcast.html'>broadcast service</a> to achieve this). 
</ul>
</ul>

<h2>Primary key properties</h2>

The primary key used by the primary must:
<ul>
<li>be immutable
<li>be of either integer or aphanumeric type
<li>use consistent sorting [specify], so that the secondary can do key comparisons client-side
</ul>

<h1>Error handling in tenant APIs</h1>

<h2>http status codes</h2>

<p>Where possible, when indicating errors, API producers should document and use existing, meaningful http error codes.
</p>

<p>For example, <b>409 Conflict</b> could be returned if a consumer tried to create object "foo" but such object already exists.
</p>

<p>If there is no suitable code, APIs should just use 400 or 500 as appropriate - we don't currently define new http status codes.
</p>

<p>The RAML for the API should document the superset of http status codes that an API may produce - no app producing the API should return any other statuses.
</p>

<h2>application/problem+json responses</h2>

<p>In addition to the status code, APIs responding with errors (other than self-explanatory ones such as 404) should also return
a body of type application/problem+json as per Problem Details for HTTP APIs.
</p>

<p>The application/problem+json format uses the "type" field (a URI) to identify the type of error.
</p>

<p>For predictable error cases (e.g. create a job application fails because the job is closed), the API documentation
should specify actual values for type. At TAS, we start our types with http://constants.talentappstore.com/httpProblems/.
For example:   

<div class='codeBlock'>
/applications:
  post:
    responses:
      200:
      500:
        body:
          application/problem+json:
            schema: !include ../schemas/applicationProblem.json
            description: |
              The app producing the API should return one of the following values in the type field where appropriate:
              - http://constants.talentappstore.com/httpProblems/jobClosed - the job is closed 
              - http://constants.talentappstore.com/httpproblems/tooLate - its after midnight 
</div>
</p>

<p>Apps may also throw errors with undocumented values for type (obviously the consumer won't be able to take any specific action in this case).
</p>


<h1>Constant resource representation in tenant APIs</h1>

<p>By convention in TAS's tenant APIs, resource representations are consistent (for a given media type).</p>

<p>That is, an API call like GET /positionOpenings (for example) returns the same data to all callers, regardless of the consuming app (or of the principal in the case of OAuth APIs).</p>

<p>This does not imply that all callers can always access the resource - in OAuth in particular, some principals might receive 403 errors depending on business rules.
However if a caller can access the resource, they will see the same data as any other caller.</p>

<p>This convention helps with scaling by allowing caching *behind* the authorisation layers in a layered architecture, for example:</p>

<div class='codeBlock'>
API consumer calls GET /positionOpenings/10334
   -> (internet)
      -> SSL offload
         -> auth
            -> business rules checking (e.g. can this principal access this resource?)
               -> cache/ reverse proxy (resource representations are constant, hence can often be cached)
                  -> origin API server (if not in cache)
</div>

<h2>Exception</h2>

<p>The exception that proves the rule is when an API ends in "/me". The responses of such API calls should not be cached. 

<h1>Tenant-specific web resources</h1>

<p>Its useful for apps to keep tenant-specific (i.e. not base domain) resources under "/t". That way the app can apply blanket handling
of the tazzy-tenant header and refuse any requests without it.
</p>  

<h1>URLs for complex resources</h1>

<p>We try and follow something like this pattern for urls of complex resources.
</p>

<pre>
Class - broad family for the resource, e.g. buttons
Who - principal type who can view the resource + actual viewer, e.g., me, anonymous, byID/{id}
Where - significant location, e.g. general, /jobs/{job} - possibly implied by who  
What - specific resource type, e.g. possibles, meta, omitted where obvious
Which - further filtering (over location), e.g. byName/{name}, byApp

e.g.: /items/toCandidate/me/jobs/{job}/itemMetas/byName/{item}

Class - /items
Who - /toCandidate/me
Where - /jobs/{job}
What - /itemMetas
Which - /byName/{item}
</pre>


<h1>SSO conventions</h1>

<h2>Common resources</h2>

<p>Most apps should have these:

<dl>

<dt>loggedIn filter</dt>
<dd>A filter that intercepts all requests with loggedIn=true and requires the principal to log in. It does this by
testing for the tazzy-saml request header, and if not found, then 302 redirecting the user to
/t/secure/redirect?redirectPage={uri}, where uri is the uri of the original target page.</dd>

<dt>filter #2</dt>
<dd>Tracker session behaviour</dd>

<dt>/t/secure/redirect?redirectPage={uri}</dt>
<dd>A redirect (http 302) hidden behind SSO. users arriving here must log in, then are immediately redirected to redirectPage. 
The redirect uri must start with "/", i.e. not be absolute - this prevents an attack where someone puts their own dodgy "enter
your credit card details" page behind your app's login to make it look legit. Apps that allow user generated content (e.g. allow someone
to host their dodgy pages on the app) should probably not have this resource.
</dd>

</dl>

<h2>Patterns</h2>

<p>SSO-enabled apps might want to use some of the following patterns for their pages:
</p>

<table border=1>
<thead>
<tr>
<th>Login required?</th>
<th>Implementation details</th>
</tr>

</thead>
<tbody>

<tr>
<td>Never</td>
<td>White-listed in the proxy's SSO settings</td>
</tr>

<tr>
<td>Always</td>
<td>Not white-listed in the proxy's SSO settings</td>
</tr>

<tr>
<td>loggedIn aware</td>
<td>All pages are typically subject to the loggedInFilter described above
</td>
</tr>

<tr>
<td>Conditional</td>
<td>e.g. job details page requires login if the job is only visible to internals, so we can see if candidate is internal:
<br />
<div class='codeBlock'>
(inside rendering code)
if [something indicates that] login required
	if tazzy-saml request header is not present
		redirect to /t/secure/redirect?redirectPage=
		  {current page URL, urlencoded}
.. else ..		
render normally		
</div>
</td>
</tr>

<tr>
<td>Conditional, but fail if not logged in</td>
<td>Resources that may require login but don't redirect to SSO, e.g. small buttons intended for rendering inside
iframes that don't provide enough room for the IdP disco panel and just display as gray if candidate not logged in.
<br />
<div class='codeBlock'>
(inside rendering code)
if [something indicates that] login required
	if tazzy-saml request header is not present
		render as gray
.. else ..		
render normally		
</div>
</td>
</tr>

<tr>
<td>Embedded login</td>
<td>Resources that render with or without login, but embed the login panel (IdP discovery service) if not logged in.
e.g. a job application form that displays but with fields grayed out if candidate is not logged in.
<br />
<div class='codeBlock'>
(inside rendering code)
if tazzy-saml request header is not present
   embed an iframe with src=/t/secure/redirect?redirectPage=
      {current page}
   when the iframe is logged in it redirects the top level window  
else
   don't embed the iframe   
</div>
</td>
</tr>

</tbody>
</table>



<h1>Correlation ID in tenant APIs</h1>

<p>To quote from <a href='http://taidevcouk.wordpress.com/2014/05/26/implementing-correlation-ids-in-spring-boot/'></a>:</p>

<p>Correlation ids are essentially an id that is generated and associated with a single (typically user-driven) request into the application
that is passed down through the stack and onto dependent services. In SOA or microservice platforms this type of id is very useful, as requests
into the application typically are ‘fanned out’ or handled by multiple downstream services, and a correlation id allows all of the downstream
requests (from the initial point of request) to be correlated or grouped based on the id. So called ‘distributed tracing’ can then be performed
using the correlation ids by combining all the downstream service logs and matching the required id to see the trace of the request throughout
your entire application stack (which is very easy if you are using a centralised logging framework such as logstash).</p>

<p>Use the same "X-Request-ID" request header used by Heroku, RoR and others.</p>


<h1>/{ct}/{ca} (consumer) and /{pt}/{pa} (producer) segments</h1>

<p><b>This needs work! Ignore for now.</b></p>

<p>Using /{ct}/{ca} (consumer) and /{pt}/{pa} (producer) segments within a tenant API's URI template
is a signal to any app producing or consuming the API that to be valid, API calls should have the (consumer) == the actual consumer,
and (producer) == the actual producer.</p>

<p>This means a tenant can install an app like a job board that consumes (say) the API <b>/jobs/byConsumer/{ct}/{ca}</b>,
confident that (as long as either (a) the consumer app obeys the convention, and/or (b) the producer enforces it) the job board
will only ever access its own postings, and not the posting for some other job board.</p>

<h2>Examples</h2>

<p>Given that the app "zambo", from the developer "zamsoft":</p>

<div class='codeBlock'>
- consumes /jobs/{ct}/{ca}
- produces /jobs/{pt}/{pa}/deltaPings
</div>

<p>...the convention means that, when installed by the tenant acme, zambo (and only zambo):</p>

<div class='codeBlock'>
- can consume		GET /jobs/acme/zamsoft/zambo
- can produce		POST /jobs/acme/zamsoft/zambo/deltaPings
</div>

<p>.. and that zambo:</p>

<div class='codeBlock'>
- can not consume	GET /jobs/acme/zamsoft/fruitbat
- will never produce	POST /jobs/acme/zamsoft/fruitbat/deltaPings
</div>

<p>In another example, the repstate app provides a centralised store where apps that act as replication secondaries
can store the position of where they are up to in the bulk load phase of replication. Other apps can look in and
summarise the readiness of all of the replication secondaries the tenant has installed.</p>

<p>Assuming the replicator cursor app:</p>

<div class='codeBlock'>
- produces /replicationStatuses/{ct}/{cad}/{ca}/{apiDev}/{apiURI}
</div>

<p>...then, when installed by the tenant acme, zambo (and only zambo):</p>

<div class='codeBlock'>
- can consume		POST /replicationStatuses/acme/zamsoft/zambo/tas/requisitions
- can consume		GET /replicationStatuses/acme/zamsoft/zambo/tas/requisitions
</div>

<p>.. and zambo:</p>

<div class='codeBlock'>
- can not consume	POST /replicationStatuses/acme/zamsoft/fruitbat/tas/requisitions
- can not consume	GET /replicationStatuses/acme/zamsoft/fruitbat/tas/requisitions
</div>

<p><b>NOTE</b>: this approach causes tighter coupling since the producer is changing its behaviour depending on who the consumer is. That implies
the tenant can't just rip and replace the consumer (just as they can't once the consumer contains its own state).</p>
 

<script>
$(document).ready(function() {

	renderSequenceDiagrams();
	renderClientIncludes();
	renderTOC();
});
</script>


</body>
</html>