<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<script src="http://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script type="text/javascript" src='http://tas-des-static.talentappstore.com/js/raphael-min.js'></script>
<script type="text/javascript" src='http://tas-des-static.talentappstore.com/js/underscore-min.js'></script>
<script type="text/javascript" src='http://tas-des-static.talentappstore.com/js/sequence-diagram-min.js'></script>
<script type="text/javascript" src='http://tas-des-static.talentappstore.com/js/tocify.js'></script>

<link rel='stylesheet' href='http://tas-des-static.talentappstore.com/css/des.css' type='text/css' media='all' />


<title>Replication</title>
</head>
<body>

<div id="toc"></div>


<h1>Purpose</h1>

<p>Replication is a convention/pattern that allows one or more <b>replication secondary</b> apps to maintain a real-time copy
of the master data held on a single <b>replication primary</b> app.</p>

<p>For example:
<ul>
<li>the replication primary app might be an ATS that produces an API like <b>GET /jobs</b>
<li>the replication secondary app might be a job board that wants to maintain its own local database of jobs, kept in synch with the jobs held on the ATS  
</ul>

<p>You shouldn't use replication unless you need to. In the example above, the job board might be able to simply call <b>GET /jobs</b> each time a
candidate visited the site. However sometimes replication is required.</p>

<p>The TAS core itself is unaware of the concept of replication. Replication is simply tenant API calls between apps as far as TAS is concerned. Your app can approach
replication in any way it wants - there is no need for it to follow this pattern. However if it does, your app will be more likely to interoperate with other apps.</p>  

<h1>Features</h1>

<p>The replication pattern described here:

<ul>
<li>Is real-time (non-polling)
<li>Supports partial replication - the secondary can choose to maintain a subset of the instances of the master records (e.g., only jobs that are currently open) 
or a subset of the properties on the instances (e.g. only the job's title, and not its description or attached documents).
<li>Relies on a bulk load phase, where immediately after install, the secondary gradually loads up all of the master data that already exists at the primary. The pattern
is best suited to a single-threaded implementation.
</ul> 


<h1>Overview</h1>

<p>Following the standard replication pattern, the ATS and job board apps in the example above would work together as below:

<ul>
<li>A tenant has already installed the ATS app (the primary)
<li>The tenant installs the job board app (the secondary)
<li>The job board app starts its bulk loading phase
<li>The job board repeatedly calls GET /jobs/{} until it has loaded all of the existing jobs from the ATS
<li>Since the bulk load phase might take hours, or days, the job board keeps track of the most recently loaded job in a persistent store (such as the repstate app), so that it can pick up and continue the bulk load phase if the tenant is disrupted, or the app itself is restarted
<li>Eventually the job board's bulk load phase is complete
<li>The job board now listens for incoming alerts about changes to the master set of jobs  
<li>At some point, a new job is created inside the ATS
<li>The ATS sends a "ping" to the job board to alert it of the new data
<li>Unless the ping is for a delete, the job board calls GET /jobs/{} to fetch the new/updated data, and updates its local database
</ul>



<h1>Example API flow</h1>

<p>Below is a detailed message sequence diagram showing the API flows between replication primary and secondary and TAS.</p>

<p>In this example, the replication primary is an ATS holding the master set of candidates, and the replication secondary is a new
candidate search app called "ferret".</p>

<p>This example also shows the use of the repstate app, which acts as a persistent store for the secondary's state during the bulk load phase.</p>

<div class='seqdiag' id="repexample" style="display:none;">

participant ats
participant ferret
participant repstate
participant TAS

note left of TAS: tenant acme installs the ferret app
TAS->ferret: POST /tenants/acme
note left of ferret: ferret knows it is a replication\nsecondary for candidates,\ninitializes the replication state store
ferret->repstate: POST /repstates/ferret/tas/%2Fcandidates\n{"loading"":true,lastLoaded:null}
note left of ferret: ferret asks for id of first candidate
ferret->ats: GET /candidates?$orderby=id&$select=id&$top=1
note right of ats: ats says 10234
note left of ferret: ferret calls its own onPing() method\nwhich fetches full details from the primary
ferret->ats: GET /candidates/10234?$select=resume
note right of ats: ats passes back resume
ferret->repstate: POST /repstates/ferret/tas/%2Fcandidates\n{"loading"":true,lastLoaded:10234}

note left of ferret: ferret asks for id of next candidate
ferret->ats: GET /candidates?$orderby=id&$select=id&$top=1&$filter=id gt 10234
note right of ats: ats says 10235
ferret->ats: GET /candidates/10235?$select=resume
note right of ats: ats passes back resume
ferret->repstate: POST /repstates/ferret/tas/%2Fcandidates\n{"loading"":true,lastLoaded:10235}

note right of ats: ..time passes..

note right of ats: a database trigger fires in the ats,\nreflecting that a new candidate has been created
note right of ats: this is the first time that ats\nhas tried to broadcast\nto this API for tenant acme,\nso asks TAS who produces that API
ats->TAS: GET /tenants/acme/routes/ats/tas/%2Fm%2Fcandidates%2F%7BcandidateID%7D%2FdeltaPings
note left of TAS: TAS says:\n"items": [{"producer": "ferret",\n"location": "https://acme.ferret.com/"},..]
note right of ats: ats now sends message to say\nthat a new candidate has been created
ats->ferret: POST /m/candidates/29046/deltaPings\n{"operation": "insert"}
note right of ferret: to decide whether to ignore the ping,\nferret needs to know the current\nstate of the replication secondary.\nIt could have this in memory or it\nit may be easier for the API handler\nto fetch it from the replication\nstatus store.
ferret->repstate: GET /repstates/ferret/tas/%2Fcandidates\n{"loading"":true,lastLoaded:10235}
note left of ferret: ferret onPing()\nif (!loading || id <= lastID) absorbPing();\nignores the ping

note left of ferret: ferret asks for id of next candidate
ferret->ats: GET /candidates?$orderby=id&$select=id&$top=1&$filter=id gt 10235
note right of ats: ats says 404 error
note left of ferret: replication bulk load is complete
ferret->repstate: POST /repstates/ferret/tas/%2Fcandidates\n{"loading"":false,lastLoaded:null}
</div>


<h1>APIs required for replication</h1>

<p>As seen above, for a given types of master data (e.g. jobs), replication requires the following APIs:

<ul>
<li>Produced by the primary and consumed by the secondary
<ul>
<li>Get a master record by its "primary key", e.g. <b>GET /jobs/{jobID}</b><br />
<li>Get the master record with the first/lowest primary key value, e.g. <b>GET /jobs?$orderby=id&$top=1</b><br />
<li>Get the master record with the next primary key value, e.g.: <b>GET /jobs?$filter=id gt 100&$orderby=id&$top=1</b><br />
</ul>
<li>Produced by the secondary and consumed by the primary
<ul>
<li>Alert secondaries of a change to a master record, e.g. <b>POST /jobs/{jobID}/deltaPings</b>.<br />
(The primary must queue pings in the event of any secondary being unavailable, until it becomes available again - it
might use something like a <a href='./broadcast.html'>broadcast service</a> to achieve this). 
</ul>
</ul>

<h1>Primary key properties</h1>

The primary key used by the primary must:
<ul>
<li>be immutable
<li>be of either integer or aphanumeric type
<li>use consistent sorting [specify], so that the secondary can do key comparisons client-side
</ul>


<script>
function render(obj) {
	// we first need to encode away the &gt; and &lt; chars we get back
	var e = document.createElement('div');
	e.innerHTML = $(obj).html();
	
	// create a div to hold the diagram
	$(obj).after("<div id='" + $(obj).attr('id') + "-diag'></div>");

	// then create diagram
	var diagram = Diagram.parse(e.childNodes[0].nodeValue);
	diagram.drawSVG($(obj).attr('id') + '-diag', {theme: 'simple'});
}	

$(document).ready(function() {

    //Executes your code when the DOM is ready.  Acts the same as $(document).ready().
    //Calls the tocify method on your HTML div.
//$("#toc").tocify();
	
	$('.seqdiag').each(function(i, obj) {
	    render(obj);
	});

	tocify('toc');
	
});
</script>


</body>
</html>